# 이분탐색 (이진탐색)

### 이분탐색 : 배열 내 데이터가 정렬이 되어 있다고 가정할 때 찾아낼 수 있는 범위를 반으로 쪼개면서 데이터를 찾는 방법입니다.
### 선형탐색 : 배열 내 데이터가 있을 때 왼쪽 혹은 오른쪽 부터 차근차근히 데이터를 찾는 방법입니다.

예를 들어 int 형 배열 {2,4,8,16,32,64,128}이 있고 64를 찾으려고 할 때 선형탐색과 이분탐색 방법을 기록하겠습니다.

![이분탐색1](https://user-images.githubusercontent.com/68115246/122530925-fa017b80-d059-11eb-980b-1c16ea199564.png)

먼저 0번째 인덱스인 2와 비교를 합니다. 다르기 때문에 인덱스에 1을 더해 다음 데이터를 확인합니다.

![이분탐색2](https://user-images.githubusercontent.com/68115246/122530933-fbcb3f00-d059-11eb-93de-5ddf606ae892.png)

1번째 인덱스인 4와 비교합니다. 다르기 때문에 인덱스에 1을 더해 다음 데이터를 확인합니다.

![이분탐색3](https://user-images.githubusercontent.com/68115246/122530940-fd950280-d059-11eb-8b99-03cf5ff0dc47.png)

2번째 인덱스를 확인합니다. 다르기 때문에 인덱스에 1을 더해 다음 데이터를 확인합니다.

![이분탐색4](https://user-images.githubusercontent.com/68115246/122530948-ff5ec600-d059-11eb-885c-def653a780e0.png)

3번째 인덱스를 확인합니다. 다르기 때문에 인덱스에 1을 더해 다음 데이터를 확인합니다.

![이분탐색5](https://user-images.githubusercontent.com/68115246/122530953-008ff300-d05a-11eb-9486-d91e055319d0.png)

4번째 인덱스를 확인합니다. 다르기 때문에 인덱스에 1을 더해 다음 데이터를 확인합니다.

![이분탐색6](https://user-images.githubusercontent.com/68115246/122530960-0259b680-d05a-11eb-9618-9626cd6ef04d.png)

5번째 인덱스를 확인합니다. 같은 값을 찾았습니다.

이 방법은 선형탐색을 통해 데이터를 확인하는 방법입니다. 배열의 길이가 7이여서 그렇게 길진 않았지만 이 데이터가 100만개 1억개 등 커진다면 연산속도가 느려질 것입니다.

반면 이분탐색은 전체 배열의 중간값을 확인한 후 탐색 후보들을 반으로 줄여나가는 방법이므로 연산속도가 선형탐색보다 빠를것입니다.
참고로 탐색하려는 후보들의 시작 인덱스를 start, 끝 인덱스를 end, 그의 가운데 값인 비교대상은 middle 입니다.

![이분탐색7](https://user-images.githubusercontent.com/68115246/122530965-04237a00-d05a-11eb-8243-4ed0c49610f2.png)

이번에는 배열의 중간 부분인 3번 인덱스의 16을 확인합니다. 결과는 달랐고, middle이 64보다 작습니다. 그래서 다음 그림에서 보겠지만 탐색했던 부분 이하 부분을 탐색 대상에서 제외한 후 길이를
다시 갱신해 start, end, middle값을 바꿉니다.

![이분탐색8](https://user-images.githubusercontent.com/68115246/122530969-05ed3d80-d05a-11eb-8e7b-196e1a420b29.png)

4번 ~ 6번 인덱스의 중간값인 5번 인덱스를 확인합니다. 결과는 64를 찾았습니다. 선형탐색에선 6번 탐색을 해야했지만 이번에는 두 번만에 데이터를 찾았습니다.

이 알고리즘은 계속해서 반으로 탐색범위를 줄여나가기 때문에 (logn)입니다.
또한 이 알고리즘은 정렬이 되있어야 합니다. 왜냐하면 대소비교를 해야하기 때문에 정렬이 되어있지 않다면 이분 탐색으로 찾을 수 없기 때문입니다.

### java 소스코드
```java
public int search(int[] arr, int num) {
  int start = 0;
  int end = arr.length - 1;
		
	while(start <= end) {
	  int mid = (start + end) / 2;
			
	  if(arr[mid] == num) {
		  return 1;//값을 찾았을 경우
	  }else if(arr[mid] > num) {
		  end = mid - 1;//찾으려는 값이 탐색한 값보다 작을 경우
	  }else {
		  start = mid + 1;//찾으려는 값이 탐색한 값보다 클 경우
	  }
  }		
  return 0;
}
  ```
